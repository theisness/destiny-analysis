# 干支反推日期算法说明

## 📋 问题描述

用户指出：根据干支计算日期的方式错误，**天干地支是60一轮回**，而不是之前使用的简化算法。

## ❌ 旧算法的问题

之前的实现使用了错误的地支12天轮回算法：

```javascript
const dayZhi = sizhu.day[1];
const zhiIndex = DI_ZHI.indexOf(dayZhi);

// ❌ 错误：假设地支12天一循环
const possibleDay = (zhiIndex + 1 + (month * 3)) % 28 + 1;
```

这个算法存在以下问题：
1. **理论错误** - 日柱是天干地支组合，60天一轮回，不是12天
2. **结果不准** - 计算出的日期与实际四柱不匹配
3. **遗漏组合** - 很多有效的干支组合无法找到对应日期

## ✅ 新算法：六十甲子

### 理论基础

**六十甲子**是中国传统纪日方法：

```
天干（10个）：甲、乙、丙、丁、戊、己、庚、辛、壬、癸
地支（12个）：子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥

组合方式：
- 天干和地支按顺序组合
- 从"甲子"开始，经过60个组合到"癸亥"
- 最小公倍数：LCM(10, 12) = 60
```

### 六十甲子表

| 序号 | 干支 | 序号 | 干支 | 序号 | 干支 | 序号 | 干支 | 序号 | 干支 |
|------|------|------|------|------|------|------|------|------|------|
| 0    | 甲子 | 12   | 丙子 | 24   | 戊子 | 36   | 庚子 | 48   | 壬子 |
| 1    | 乙丑 | 13   | 丁丑 | 25   | 己丑 | 37   | 辛丑 | 49   | 癸丑 |
| 2    | 丙寅 | 14   | 戊寅 | 26   | 庚寅 | 38   | 壬寅 | 50   | 甲寅 |
| 3    | 丁卯 | 15   | 己卯 | 27   | 辛卯 | 39   | 癸卯 | 51   | 乙卯 |
| 4    | 戊辰 | 16   | 庚辰 | 28   | 壬辰 | 40   | 甲辰 | 52   | 丙辰 |
| 5    | 己巳 | 17   | 辛巳 | 29   | 癸巳 | 41   | 乙巳 | 53   | 丁巳 |
| 6    | 庚午 | 18   | 壬午 | 30   | 甲午 | 42   | 丙午 | 54   | 戊午 |
| 7    | 辛未 | 19   | 癸未 | 31   | 乙未 | 43   | 丁未 | 55   | 己未 |
| 8    | 壬申 | 20   | 甲申 | 32   | 丙申 | 44   | 戊申 | 56   | 庚申 |
| 9    | 癸酉 | 21   | 乙酉 | 33   | 丁酉 | 45   | 己酉 | 57   | 辛酉 |
| 10   | 甲戌 | 22   | 丙戌 | 34   | 戊戌 | 46   | 庚戌 | 58   | 壬戌 |
| 11   | 乙亥 | 23   | 丁亥 | 35   | 己亥 | 47   | 辛亥 | 59   | 癸亥 |

### 计算干支序号

给定一个干支组合，计算其在六十甲子中的序号：

```javascript
const getDayGanZhiIndex = (ganZhi) => {
  const gan = ganZhi[0];        // 天干
  const zhi = ganZhi[1];        // 地支
  const ganIndex = TIAN_GAN.indexOf(gan);   // 0-9
  const zhiIndex = DI_ZHI.indexOf(zhi);     // 0-11
  
  // 找到满足条件的序号 i：
  // i % 10 === ganIndex  (天干匹配)
  // i % 12 === zhiIndex  (地支匹配)
  for (let i = 0; i < 60; i++) {
    if (i % 10 === ganIndex && i % 12 === zhiIndex) {
      return i;
    }
  }
  return 0;
};
```

**示例**：
- 甲子：ganIndex=0, zhiIndex=0 → 序号=0
- 乙丑：ganIndex=1, zhiIndex=1 → 序号=1
- 甲戌：ganIndex=0, zhiIndex=10 → 序号=10

## 🔧 实现方案

### 方案一：后端 API（首选）

创建 `/api/bazi/reverse-calculate` 端点，使用 `lunar-javascript` 库精确计算：

```javascript
router.post('/reverse-calculate', protect, async (req, res) => {
  const { sizhu } = req.body;
  const { Solar } = require('lunar-javascript');
  const dates = [];
  
  // 遍历日期范围
  for (let year = startYear; year <= endYear; year++) {
    for (let month = 1; month <= 12; month++) {
      for (let day = 1; day <= daysInMonth; day++) {
        // 根据时柱推算时辰
        const hour = hourIndex * 2;
        
        // 使用 lunar-javascript 计算四柱
        const solar = Solar.fromYmdHms(year, month, day, hour, 0, 0);
        const lunar = solar.getLunar();
        
        const yearGanZhi = lunar.getYearInGanZhi();
        const monthGanZhi = lunar.getMonthInGanZhi();
        const dayGanZhi = lunar.getDayInGanZhi();
        const timeGanZhi = lunar.getTimeInGanZhi();
        
        // 完全匹配四柱
        if (yearGanZhi === sizhu.year && 
            monthGanZhi === sizhu.month && 
            dayGanZhi === sizhu.day && 
            timeGanZhi === sizhu.hour) {
          dates.push({ year, month, day, hour });
        }
      }
    }
  }
  
  res.json({ success: true, dates });
});
```

**优点**：
- ✅ 精确匹配所有四柱
- ✅ 考虑了月柱和年柱的计算规则
- ✅ 使用成熟的天文历法库

### 方案二：前端降级计算

如果后端 API 不可用，前端使用六十甲子算法：

```javascript
const calculatePossibleDatesLocal = () => {
  const dates = [];
  const targetDayIndex = getDayGanZhiIndex(sizhu.day);
  
  // 基准日：1900年1月1日 = 甲戌日（序号10）
  const baseDate = new Date(1900, 0, 1);
  const baseDayIndex = 10;
  
  // 遍历日期
  for (let year = startYear; year <= endYear; year++) {
    for (let month = 1; month <= 12; month++) {
      for (let day = 1; day <= daysInMonth; day++) {
        const checkDate = new Date(year, month - 1, day);
        
        // 计算天数差
        const diffDays = Math.floor(
          (checkDate - baseDate) / (1000 * 60 * 60 * 24)
        );
        
        // 计算干支序号
        const currentDayIndex = (baseDayIndex + diffDays) % 60;
        
        // 匹配日柱
        if (currentDayIndex === targetDayIndex) {
          dates.push({ year, month, day, hour });
        }
      }
    }
  }
  
  return dates;
};
```

**优点**：
- ✅ 使用正确的六十甲子算法
- ✅ 无需后端支持
- ✅ 适合作为降级方案

**局限**：
- ⚠️ 只能精确匹配日柱
- ⚠️ 月柱、年柱的匹配不够准确（需要考虑节气）

## 📊 算法对比

| 特性 | 旧算法 | 前端六十甲子 | 后端 API |
|------|--------|-------------|----------|
| 理论正确性 | ❌ 错误 | ✅ 正确 | ✅ 正确 |
| 日柱匹配 | ❌ 不准确 | ✅ 精确 | ✅ 精确 |
| 时柱匹配 | ⚠️ 简化 | ✅ 准确 | ✅ 精确 |
| 月柱匹配 | ❌ 无 | ⚠️ 不准确 | ✅ 精确 |
| 年柱匹配 | ❌ 无 | ⚠️ 不准确 | ✅ 精确 |
| 性能 | 快 | 中等 | 较慢 |
| 依赖 | 无 | 无 | 后端 |

## 🎯 使用建议

1. **首选后端 API** - 获取最准确的结果
2. **前端降级** - 当后端不可用时使用
3. **用户选择** - 如果找不到匹配日期，提供"直接使用四柱"选项

## 📚 参考资料

- [六十甲子 - 维基百科](https://zh.wikipedia.org/wiki/六十甲子)
- [lunar-javascript 文档](https://github.com/6tail/lunar-javascript)
- [干支纪日法](https://baike.baidu.com/item/干支纪日法)

## 🔗 相关文件

- `backend/routes/bazi.js` - 后端反推 API
- `frontend/src/pages/BaziInput/BaziInput.js` - 前端计算逻辑
- `更新日志.md` - v1.2.0 更新说明

